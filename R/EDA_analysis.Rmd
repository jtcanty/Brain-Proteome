---
title: "EDA_analysis"
output: pdf_document
---

```{r Import libaries, echo=FALSE, include=FALSE}
library(readxl)
library(ggplot2)
library(SummarizedExperiment)
library(dplyr)
library(rafalib)
library(limma)
```

```{r Open TMT Data Summary, include=TRUE}
# FC - Frontal Cortex
# ACG = Anterior Cingulate Gyrus
FC_Data <- read_excel("/home/john/Documents/Coding/Brain-Proteome/data/TMT_Summary_Data.xlsx", sheet=1, skip=2)
ACG_Data <- read_excel("/home/john/Documents/Coding/Brain-Proteome/data/TMT_Summary_Data.xlsx", sheet=2, skip=2)

# READ:    Comment out depending on data-set of interest
#TMT_Summary_Data <- ACG_Data
TMT_Summary_Data <- FC_Data
View(TMT_Summary_Data)
```

```{r Preprocess dataset, include=TRUE}
nGenes <- nrow(TMT_Summary_Data)
nCols <- ncol(TMT_Summary_Data)

# Convert zeros to NA
TMT_Summary_Data[TMT_Summary_Data == 0] <- NA

# Remove NAs from the dataset
nanIdx <- is.na(TMT_Summary_Data[,7:nCols])
numNans <- rowSums(nanIdx)
filtered_TMT_Summary_Data <- TMT_Summary_Data[numNans < 1,]

# Save the data
save(filtered_TMT_Summary_Data, file='filtered_TMT_Summary_Data.RData')
```

```{r Create Summarized Experiment, include=TRUE}
# Import TMT data into a Summarized Experiment
filtered_TMT_Summary_Data_SE <- filtered_TMT_Summary_Data

colnames(filtered_TMT_Summary_Data_SE) <- NULL
rowData <- DataFrame(Accession_ID=filtered_TMT_Summary_Data_SE[,1], 
                     Gene=filtered_TMT_Summary_Data_SE[,2],
                     Description=filtered_TMT_Summary_Data_SE[,3])
colData <- DataFrame(Disease=c("Alzheimers","Alzheimers","Control","Control","Parkinsons","Parkinsons","Comorbid","Comorbid"),
                     row.names=c("AD1","AD2","CTL1","CTL2","PD1","PD2","ADPD1","ADPD2"))

exp <- SummarizedExperiment(assays=list(batch1=(filtered_TMT_Summary_Data_SE[,7:14]),
                                        batch2=(filtered_TMT_Summary_Data_SE[,15:22]),
                                        batch3=(filtered_TMT_Summary_Data_SE[,23:30]),
                                        batch4=(filtered_TMT_Summary_Data_SE[,31:38]),
                                        batch5=(filtered_TMT_Summary_Data_SE[,39:46])),
                                        rowData=rowData, colData=colData)
```

```{r Create boxplot of batches}
# Display samples in box-plots. Color by attribute and color by batch number.
Raw_TMT_Summary_Data <- filtered_TMT_Summary_Data[,7:nCols]

batchColors = rep(c('red','red','black','black','blue','blue','green','green'), 5)

p <- ggplot(stack(Raw_TMT_Summary_Data), aes(x = ind, y = values)) + geom_boxplot(aes(fill=values)) + geom_point(aes(color=ind))
p + scale_color_manual(values= batchColors) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
    xlab('Patient sample') + ylab('Log-fold expression')

```{r}
# Loess normalization of data
Loess_TMT_Summary_Data <- as.data.frame(normalizeBetweenArrays(filtered_TMT_Summary_Data[,7:nCols], method='cyclicloess'))
p2 <- ggplot(stack(Loess_TMT_Summary_Data), aes(x = ind, y = values)) + geom_boxplot(aes(fill=values)) + geom_point(aes(color=ind))
p2 + scale_color_manual(values= batchColors) +
     theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
     xlab('Patient sample') + ylab('Log-fold expression')
# Plot summary of statistics
summary(Loess_TMT_Summary_Data)
```
```{r PCA analysis, include=TRUE}
lData <- Loess_TMT_Summary_Data
# Extract samples for each disease-state
Ctl <- as.data.frame(sapply(1:10, function(i) select(lData, sprintf("CTL%d",i))))
PD <- as.data.frame(sapply(1:10, function(i) select(lData, sprintf("PD%d",i))))
AD <- as.data.frame(sapply(1:10, function(i) select(lData, sprintf("AD%d",i))))
AD_PD <- as.data.frame(sapply(1:10, function(i) select(lData, sprintf("ADPD%d",i))))
Ctl_vs_PD <- cbind(Ctl, PD)
Ctl_vs_AD <- cbind(Ctl, AD)
Ctl_vs_AD_PD <- cbind(Ctl, AD_PD)
# PCA analysis for all classes
PCA <- prcomp(t(lData))
plot(PCA$x[,1], PCA$x[,2], pch=16, col=batchColors, xlab='PCA 1', ylab='PCA 2')
# Perform PCA analysis on Ctl versus disease-state
PCA_CtlvsPD <- prcomp(t(Ctl_vs_PD))
PCA_CtlvsAD <- prcomp(t(Ctl_vs_AD))
PCA_CtlvsADPD <- prcomp(t(Ctl_vs_AD_PD))
# Plot PCA
CtlvsPD_Colors <- c(rep('black',10), rep('blue', 10))
CtlvsAD_Colors <- c(rep('black',10), rep('red', 10))
CtlvsPDAD_Colors <- c(rep('black',10), rep('green', 10))
pairs(PCA_CtlvsPD$x[,1:3], col=CtlvsPD_Colors, pch=16, oma=c(3,3,3,15))
opar <- par(no.readonly=TRUE)
par(xpd = TRUE)
legend('bottomright',fill=c('black','blue'), legend = c('Ctl','PD'))
par(opar)
pairs(PCA_CtlvsAD$x[,1:3], col=CtlvsAD_Colors, pch=16, oma=c(3,3,3,15))
opar <- par(no.readonly=TRUE)
par(xpd = TRUE)
legend('bottomright',fill=c('black','red'), legend = c('Ctl','AD'))
par(opar)
pairs(PCA_CtlvsADPD$x[,1:3], col=CtlvsPDAD_Colors, pch=16, oma=c(3,3,3,15))
par(xpd = TRUE)
legend('bottomright',fill=c('black','green'), legend = c('Ctl','PD_AD'))
```

```{r}
# Quantile normalization of data
Quantile_TMT_Summary_Data <- as.data.frame(normalizeBetweenArrays(filtered_TMT_Summary_Data[,7:nCols], method='quantile'))

p2 <- ggplot(stack(Quantile_TMT_Summary_Data), aes(x = ind, y = values)) + geom_boxplot(aes(fill=values)) + geom_point(aes(color=ind))
p2 + scale_color_manual(values= batchColors) +
     theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
     xlab('Patient sample') + ylab('Log-fold expression')

# Plot summary of statistics
summary(Quantile_TMT_Summary_Data)
```

```{r PCA analysis, include=TRUE}
qData <- Quantile_TMT_Summary_Data

# Extract samples for each disease-state
Ctl <- as.data.frame(sapply(1:10, function(i) select(qData, sprintf("CTL%d",i))))
PD <- as.data.frame(sapply(1:10, function(i) select(qData, sprintf("PD%d",i))))
AD <- as.data.frame(sapply(1:10, function(i) select(qData, sprintf("AD%d",i))))
AD_PD <- as.data.frame(sapply(1:10, function(i) select(qData, sprintf("ADPD%d",i))))

Ctl_vs_PD <- cbind(Ctl, PD)
Ctl_vs_AD <- cbind(Ctl, AD)
Ctl_vs_AD_PD <- cbind(Ctl, AD_PD)

# PCA analysis for all classes
PCA <- prcomp(t(qData))
plot(PCA$x[,1], PCA$x[,2], pch=16, col=batchColors, xlab='PCA 1', ylab='PCA 2')

# Perform PCA analysis on Ctl versus disease-state
PCA_CtlvsPD <- prcomp(t(Ctl_vs_PD))
PCA_CtlvsAD <- prcomp(t(Ctl_vs_AD))
PCA_CtlvsADPD <- prcomp(t(Ctl_vs_AD_PD))

# Plot PCA
CtlvsPD_Colors <- c(rep('black',10), rep('blue', 10))
CtlvsAD_Colors <- c(rep('black',10), rep('red', 10))
CtlvsPDAD_Colors <- c(rep('black',10), rep('green', 10))

pairs(PCA_CtlvsPD$x[,1:3], col=CtlvsPD_Colors, pch=16, oma=c(3,3,3,15))
opar <- par(no.readonly=TRUE)
par(xpd = TRUE)
legend('bottomright',fill=c('black','blue'), legend = c('Ctl','PD'))
par(opar)

pairs(PCA_CtlvsAD$x[,1:3], col=CtlvsAD_Colors, pch=16, oma=c(3,3,3,15))
opar <- par(no.readonly=TRUE)
par(xpd = TRUE)
legend('bottomright',fill=c('black','red'), legend = c('Ctl','AD'))
par(opar)

pairs(PCA_CtlvsADPD$x[,1:3], col=CtlvsPDAD_Colors, pch=16, oma=c(3,3,3,15))
par(xpd = TRUE)
legend('bottomright',fill=c('black','green'), legend = c('Ctl','PD_AD'))
```

```{r SVM, include=TRUE}
library("e1071")
category <- rep(c("AD","AD","PD","PD","AD_PD","AD_PD","Ctl","Ctl"),5)
dat=data.frame(x=PCA$x[,1:2], y=as.factor(category))
# support vector machine for all classes based on the 2 principal components
svmfit=svm(y~., data=dat, kernel="radial", gamma=1, cost=10) 
plot(svmfit, dat)
table(true=dat[, "y"], pred=predict(svmfit, newdata=dat[,]))
# getting the best parameter combination
best.tune(svm, y~., data=dat[,], kernel="radial", ranges=list(cost=c(0.1, 1, 10, 100, 1000), gamma=c(0.5, 1, 2, 3, 4)))

# plot pairwise classification
CP <- data.frame(x=PCA_CtlvsPD$x[,1:2], y=as.factor(c(rep("Ctl",10),rep("PD",10))))
CA <- data.frame(x=PCA_CtlvsAD$x[,1:2], y=as.factor(c(rep("Ctl",10),rep("AD",10))))
CAP <- data.frame(x=PCA_CtlvsADPD$x[,1:2], y=as.factor(c(rep("Ctl",10),rep("ADPD",10))))
svmfit=svm(y~., data=CP, kernel="radial", gamma=1, cost=10) 
plot(svmfit, dat)
table(true=CP[, "y"], pred=predict(svmfit, newdata=CP[,]))
svmfit=svm(y~., data=CA, kernel="radial", gamma=1, cost=10) 
plot(svmfit, dat)
table(true=CA[, "y"], pred=predict(svmfit, newdata=CA[,]))
svmfit=svm(y~., data=CAP, kernel="radial", gamma=1, cost=10) 
plot(svmfit, dat)
table(true=CAP[, "y"], pred=predict(svmfit, newdata=CAP[,]))
```

```{r tree, include=TRUE}
library(tree)
# train the tree
dat=data.frame(x=PCA$x, y=as.factor(category))
out.tre<-tree(y~., dat)
# plot the tree
plot(out.tre)
text(out.tre)
# predict response
Y.tre<-predict(out.tre, dat, type="class")
sum(Y.tre != as.factor(category)) / length(category)
```







